/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Go.jj */
/*@egen*/options {
                                               
                                                            
               
                 
}

PARSER_BEGIN(GoParser)
package wci.frontend;

import java.util.ArrayList;
import java.io.*;

import wci.intermediate.*;
import wci.intermediate.symtabimpl.*;
import wci.backend.*;
import wci.util.*;

import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.symtabimpl.DefinitionImpl.*;
import static wci.intermediate.symtabimpl.RoutineCodeImpl.*;
import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.icodeimpl.ICodeKeyImpl.*;

public class GoParser/*@bgen(jjtree)*/implements GoParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTGoParserState jjtree = new JJTGoParserState();

/*@egen*/
    private static final String SOURCE_SUFFIX = ".go";
    private static final String OUTPUT_SUFFIX = ".j";

    private static SymTabStack symTabStack;
    private static SymTabEntry programId;

    public static void main(String[] args)
        throws Exception
    {
        // Create and initialize the symbol table stack.
        symTabStack = SymTabFactory.createSymTabStack();
        Predefined.initialize(symTabStack);

        // Process the source file path which ends in .go
        // and create the output file path which ends in .j
        String sourceFilePath = args[0];
        int truncatedLength = sourceFilePath.length() - SOURCE_SUFFIX.length();
        int suffixIndex = sourceFilePath.lastIndexOf(SOURCE_SUFFIX);
        String objectFilePath = (suffixIndex == truncatedLength)
            ? sourceFilePath.substring(0, truncatedLength) + OUTPUT_SUFFIX
            : sourceFilePath + OUTPUT_SUFFIX;

        // Parse a Go program.
        Reader reader = new FileReader(sourceFilePath);
        PclParser parser = new PclParser(reader);
        SimpleNode rootNode = parser.start();

        // Print the cross-reference table.
        CrossReferencer crossReferencer = new CrossReferencer();
        crossReferencer.print(symTabStack);

        // Visit the parse tree nodes to decorate them with type information.
        TypeSetterVisitor typeVisitor = new TypeSetterVisitor();
        rootNode.jjtAccept(typeVisitor, null);

        // Create and initialize the ICode wrapper for the parse tree.
        ICode iCode = ICodeFactory.createICode();
        iCode.setRoot(rootNode);
        programId.setAttribute(ROUTINE_ICODE, iCode);

        // Print the parse tree.
        ParseTreePrinter treePrinter = new ParseTreePrinter(System.out);
        treePrinter.print(symTabStack);
    }
}
PARSER_END(GoParser)

SKIP : {
   <IGNORE : [" ", "\r", "\n", "\t"]>
   | <"//" (~["\n", "\r"])*>
   | <"/*"> : MULTI_LINE_COMMENT
}

<MULTI_LINE_COMMENT> SKIP: {
    "*/" : DEFAULT
}

<MULTI_LINE_COMMENT> MORE: {
    <~[]>
}

/*************************
  -- Production Rules --
*************************/

void start() : {/*@bgen(jjtree) start */
  ASTstart jjtn000 = new ASTstart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) start */
    try {
/*@egen*/
    try {
        (
            statement()
        )*
        <EOF> {
            return rootNode;
        }
    }
    catch (ParseException ex) {
        handleError(ex);
        return null;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void statement() : {/*@bgen(jjtree) statement */
  ASTstatement jjtn000 = new ASTstatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) statement */
    try {
/*@egen*/
    ({ System.out.println("\n==========ASSIGNMENT========="); } assignmentStatement())
    | ({ System.out.println("\n==========SWITCH STATEMENT========="); } switchStatement())
//    | ({ System.out.println("\n==========IF STATEMENT========="); } ifStatement())
    | ({ System.out.println("\n==========FOR STATEMENT========="); } forStatement())
    | (";"/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ { System.out.print(token.image); })/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void statementList() : {/*@bgen(jjtree) statementList */
  ASTstatementList jjtn000 = new ASTstatementList(JJTSTATEMENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) statementList */
    try {
/*@egen*/
    (statement())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void block() : {/*@bgen(jjtree) block */
  ASTblock jjtn000 = new ASTblock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) block */
    try {
/*@egen*/
    "{" { System.out.print(" " + token.image + "\n\t"); }
    statementList()
    "}"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ { System.out.print("\n" + token.image + "\n"); }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/*
void ifStatement() : {}
{
    "if" { System.out.print(token.image + " "); }
    expression()
    block()
    (LOOKAHEAD(2) "else" { System.out.print(token.image + " "); } "if" { System.out.print(token.image + " "); } expression() block())*
    ("else" { System.out.print(token.image + " "); } block())?
}
*/

void switchStatement() : {/*@bgen(jjtree) switchStatement */
  ASTswitchStatement jjtn000 = new ASTswitchStatement(JJTSWITCHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) switchStatement */
    try {
/*@egen*/
    "switch" { System.out.print(token.image + " "); }
    (expression())?
    switchBlock()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void switchBlock() : {/*@bgen(jjtree) switchBlock */
  ASTswitchBlock jjtn000 = new ASTswitchBlock(JJTSWITCHBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) switchBlock */
    try {
/*@egen*/
    "{" { System.out.print(" " + token.image + "\n\t"); }
    caseGroup()
    "}"/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ { System.out.print("\n" + token.image + "\n"); }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void caseGroup() : {/*@bgen(jjtree) caseGroup */
  ASTcaseGroup jjtn000 = new ASTcaseGroup(JJTCASEGROUP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) caseGroup */
    try {
/*@egen*/
    (
        "case" { System.out.print("\n" + token.image + " "); }
        expressionList()
        ":" { System.out.print(token.image); }
        statementList()
    )*

    (
        "default" { System.out.print("\n" + token.image); } ":" { System.out.print(token.image + " "); }
        statementList()
    )?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void assignmentStatement() : {/*@bgen(jjtree) assignmentStatement */
  ASTassignmentStatement jjtn000 = new ASTassignmentStatement(JJTASSIGNMENTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) assignmentStatement */
    try {
/*@egen*/
    (
        <IDENTIFIER> { System.out.print(token.image); }
        (
            (
                (
                    ("=" | ":=") { System.out.print(token.image); }
                    operand() ((<ADD_OP> | <MUL_OP>) { System.out.print(token.image + " "); } operand())*
                )
                |
                    incOrDec()
            )

            (LOOKAHEAD(2) ";" { System.out.print(token.image); })?
        )
    )
    |
    (
        incOrDec()
        <IDENTIFIER>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ { System.out.print(token.image); }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void incOrDec() : {/*@bgen(jjtree) incOrDec */
  ASTincOrDec jjtn000 = new ASTincOrDec(JJTINCORDEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) incOrDec */
    try {
/*@egen*/
    ("++" | "--")/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ { System.out.print(token.image); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void forStatement() : {/*@bgen(jjtree) forStatement */
  ASTforStatement jjtn000 = new ASTforStatement(JJTFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) forStatement */
    try {
/*@egen*/
    "for" { System.out.print(token.image + " "); }
    forClause()
    block()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void forClause() : {/*@bgen(jjtree) forClause */
  ASTforClause jjtn000 = new ASTforClause(JJTFORCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) forClause */
    try {
/*@egen*/
    (LOOKAHEAD(2) assignmentStatement())?
    (LOOKAHEAD(2) expression())? (";" { System.out.print(token.image); })?
    (assignmentStatement())?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// TODO: Not currently used. Delete or use it?
void rangeClause() : {/*@bgen(jjtree) rangeClause */
  ASTrangeClause jjtn000 = new ASTrangeClause(JJTRANGECLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) rangeClause */
    try {
/*@egen*/
    (
        LOOKAHEAD(2)

        expression() "=" { System.out.print(token.image); }
        |
        <IDENTIFIER> { System.out.print(token.image); }

        ":=" { System.out.print(token.image); }
    )

    "range" { System.out.print(token.image); } expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void operand(): {/*@bgen(jjtree) operand */
  ASToperand jjtn000 = new ASToperand(JJTOPERAND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) operand */
    try {
/*@egen*/
    (
        (
            (<INTEGER_NUMBER> | <REAL_NUMBER> | <RAW_STRING> | <INTERPRETED_STRING>
            | <IDENTIFIER>)/*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn000, true);
                              jjtc000 = false;
                            }
/*@egen*/ { System.out.print(token.image); }
        )
        |
        (
            "(" { System.out.print(token.image + " "); }
            expression()
            ")"/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ { System.out.print(token.image + " "); }
        )
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void expression() : {/*@bgen(jjtree) expression */
  ASTexpression jjtn000 = new ASTexpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) expression */
    try {
/*@egen*/
    operand() (<BINARY_OP> { System.out.print(token.image + " "); } operand())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void expressionList() : {/*@bgen(jjtree) expressionList */
  ASTexpressionList jjtn000 = new ASTexpressionList(JJTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) expressionList */
    try {
/*@egen*/
    expression() ("," { System.out.print(token.image + " "); } expression())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/********************s
    -- Tokens --
********************/

TOKEN : {
    <SEMICOLON: ";">
    |
    <ERROR : ~["\r", "\n"]>
    |
    <RESERVED_WORD: "break" | "default" | "func" | "interface" | "select" | "case" | "defer"
        | "go" | "map" | "struct" | "chan" | "else" | "goto" | "package" | "switch"
        | "const" | "fallthrough" | "if" | "range" | "type" | "continue"
        | "for" | "import" | "return" | "var">
        //{ debugStream.println("\nRESERVED_WORD token: " + matchedToken.image); }
    |
    <INTEGER_NUMBER: <DIGIT> (<DIGIT>)*>
        //{ debugStream.println("\nINTEGER_NUMBER token: " + matchedToken.image); }
    |
    <REAL_NUMBER: <INTEGER_NUMBER> "." (<INTEGER_NUMBER>)?>
        //{ debugStream.println("\nREAL_NUMBER token: " + matchedToken.image); }
    |
    <RAW_STRING: "`" (<ALPHANUMERIC> | <RAW_LITERAL_SYMBOL> | <NEWLINE>)* "`">
        //{ debugStream.println("\nRAW_STRING token: " + matchedToken.image); }
    |
    <INTERPRETED_STRING: "\"" (<ALPHANUMERIC> | <ESCAPED_CHAR>
            | <INTERPRETED_LITERAL_SYMBOL> | <WHITE_SPACE>)* "\"">
        //{ debugStream.println("\nINTERPRETED_STRING token: " + matchedToken.image); }

        | <#NEWLINE: ["\r", "\n"]>
        | <#ESCAPED_CHAR: "\\" ("a" | "b" | "f" | "n" | "r" | "t" | "v" | "\\" | "'" | "\"")>
        | <#WHITE_SPACE: <NEWLINE> | "\t" | " ">
    |
    <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT> | "_")*>
         //{ debugStream.println("\nIDENTIFIER token: " + matchedToken.image); }
        |
        <IDENTIFIER_LIST: <IDENTIFIER> ("," <IDENTIFIER>)*>
    /*
    |
    <SPECIAL_SYMBOL:
        "+" | "&" | "+=" | "&=" | "&&" | "==" | "!=" | "(" | ")"
        | "-" | "|" | "-=" | "|=" | "||" | "<" | "<=" | "[" | "]"
        | "*" | "^" | "*=" | "^=" | "<-" | ">" | ">=" | "{"  | "}"
        | "/" | "<<" | "/=" | "<<=" | "++" | "=" | ":=" | "," | ";"
        | "%" | ">>" | "%=" | ">>=" | "--" | "!" | "..." |  "." | ":"
        | "&^" | "&^=">
        { debugStream.println("\nSPECIAL_SYMBOL token: " + matchedToken.image); }
    */
        | <#LETTER: ["a"-"z", "A"-"Z"]>
        | <#DIGIT: ["0"-"9"]>
        | <#ALPHANUMERIC: (<LETTER> | <DIGIT>)+>
        | <ADD_OP: ["+", "-"]>
        | <MUL_OP: ("*" | "/" | "%")>
        | <#REL_OP: "==" | "!=" | "<" | "<=" | ">" | ">=">
        | <UNARY_OP: "+" | "-" | "!" | "^" | "*" | "&">
        | <ASSIGN_OP: (<ADD_OP> | <MUL_OP>)? "=">
        | <BINARY_OP: "||" | "&&" | <REL_OP> | <ADD_OP>| <MUL_OP>>
        | <#COMMON_LITERAL_SYMBOL: "~" | "!" | "@" | "#" | "$" | "%" | "^"
            | "&" | "*"| "(" | ")" | "_" | "-" | "+" | "=" | "<" | ">"
            | "," | "." | "/"| "?" | ":" | ";" | "[" | "]" | "{" | "}" | "|">
        | <#RAW_LITERAL_SYMBOL: <COMMON_LITERAL_SYMBOL> | "\"" | "\\">
        | <#INTERPRETED_LITERAL_SYMBOL: <COMMON_LITERAL_SYMBOL> | "'">
}

void Error()       : {}
{
    <ERROR>
}

JAVACODE
void processVariableDecl(Token token, int index, ArrayList<SymTabEntry> variableList)      
{
    SymTabEntry variableId = symTabStack.enterLocal(token.image);
    variableId.setIndex(index);
    variableId.setDefinition(DefinitionImpl.VARIABLE);
    variableId.appendLineNumber(token.beginLine);
    variableList.add(variableId);
}

JAVACODE
String handleError(ParseException ex)      
{
    Token token = ex.currentToken;
    System.out.println(ex.getMessage());

    do {
    	token = getNextToken();
    } while (token.kind != SEMICOLON);

	jjtree.popNode();
    return token.image;
}