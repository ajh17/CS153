options {
    BUILD_PARSER=true;
    OUTPUT_DIRECTORY="src/";
    UNICODE_INPUT=true;
    DEBUG_TOKEN_MANAGER=true;
}

PARSER_BEGIN(Assignment6)
    public class Assignment6 {}
PARSER_END(Assignment6)

SKIP : {
   <IGNORE : [" ", "\r", "\n", "\t"]>
   | <"//" (~["\n", "\r"])*>
   | <"/*"> : MULTI_LINE_COMMENT
}

<MULTI_LINE_COMMENT> SKIP: {
    "*/" : DEFAULT
}

<MULTI_LINE_COMMENT> MORE: {
    <~[]>
}

TOKEN_MGR_DECLS : {
    public static void main(String[] args)
    {
        StringBuilder fileString = new StringBuilder();
        java.io.BufferedReader br = null;
        if (args.length != 2) {
            // Javacc doesn't compile with println statements.
        }
        try {
            br = new java.io.BufferedReader(new java.io.InputStreamReader(new
                        java.io.FileInputStream(args[0]), "UTF-16"));
            int i = 0;
            char[] buffer = new char[1024];

            while ((i = br.read(buffer)) != -1)
                fileString.append(buffer, 0, i);
        }
        catch (java.io.IOException ex) {
        }
        finally {
            try {
                br.close();
            }
            catch (java.io.IOException ex) {
            }
        }

        java.io.StringReader sr = new java.io.StringReader(fileString.toString());
        SimpleCharStream scs = new SimpleCharStream(sr);
        Assignment6TokenManager mgr = new Assignment6TokenManager(scs);

        while (mgr.getNextToken().kind != EOF) {}
    }
}

// TODO: Reserved word tokens may be removed depending on the subset of Go we choose.
// TODO: Decide whether we want to implement Unicode at all. If so, change appropriate tokens.
// TODO: Implement string token. Go has "" type strings and `` type strings (`` are raw strings)
// TODO: Go also has "rune" that's (as far as I know) is aliased to int16.
// TODO: Implement Go Expressions and Statements
TOKEN : {
    <LITERAL: <BASIC_LITERAL>>
    |
    <BASIC_LITERAL: <INTEGER_NUMBER> <REAL_NUMBER> <IMAGINARY_NUMBER> <STRING>>
        { debugStream.println("BASIC_LITERAL token: " + matchedToken.image); }
    |
     <SIMPLE_STATEMENT: (<ASSIGNMENT_STATEMENT> | <EXPRESSION> | <SHORT_VAR_DECLR> | <INCDEC_STATEMENT>)?>
        { debugStream.println("SIMPLE_STATEMENT token: " + matchedToken.image); }
    |
    <ASSIGNMENT_STATEMENT: <EXPRESSION_LIST> <ASSIGN_OPER> <EXPRESSION_LIST>>
        { debugStream.println("ASSIGNMENT_STATEMENT token: " + matchedToken.image); }
    |
    <ASSIGN_OPER: (<ADD_OP> | <MUL_OP>)? "=">
        { debugStream.println("ASSIGN_OPER token: " + matchedToken.image); }
    |
    <METHOD_EXPRESSION: <RECEIVER_TYPE> "." <METHOD_NAME>>
    |
    <RECEIVER_TYPE: <TYPE_NAME> | ("(" "*" <TYPE_NAME> ")") | ("(" <RECEIVER_TYPE> ")")>
    |
    <METHOD_NAME: <IDENTIFIER>>
    |
    <TYPE_NAME: <IDENTIFIER> | <QUALIFIED_IDENTIFIER>>
    |
    <QUALIFIED_IDENTIFIER: <IDENTIFIER> "." <IDENTIFIER>>
    |
    <EXPRESSION: <UNARY_EXPRESSION> | (<EXPRESSION> <BINARY_OP> <EXPRESSION>)>
    |
    <UNARY_EXPRESSION: <PRIMARY_EXPRESSION> | <UNARY_OP> <UNARY_EXPRESSION>>
    |
    <PRIMARY_EXPRESSION: <OPERAND> | <CONVERSION> | <BUILTIN_CALL>>
    |
    <BUILTIN_CALL: <IDENTIFIER> "(" (<BUILTIN_ARGS> (",")?)? ")">
    |
    <BUILTIN_ARGS: (<TYPE> ("," <ARGUMENT_LIST>)?) | <ARGUMENT_LIST>>
    |
    <ARGUMENT_LIST: <EXPRESSION_LIST> ("...")?>
    |
    <OPERAND: <LITERAL> | <OPERAND_NAME> | <METHOD_EXPRESSION> | ("(" <EXPRESSION> ")")>
    |
    <OPERAND_NAME: <IDENTIFIER> | <QUALIFIED_IDENTIFIER>>
    |
    <CONVERSION: <TYPE> "(" <EXPRESSION> (",")? ")">
    |
    <TYPE: <TYPE_NAME> | ("(" <TYPE> ")")>
    |
    <SHORT_VAR_DECLR: <IDENTIFIER> ":=" <EXPRESSION_LIST>>
       { debugStream.println("SHORT_VAR_DECLR token: " + matchedToken.image); }
    |
    <RESERVED_WORD: 
    "break" | "default" | "func" | "interface" | "select" | "case" | "defer"
    | "go" | "map" | "struct" | "chan" | "else" | "goto" | "package" | "switch"
    | "const" | "fallthrough" | "if" | "range" | "type" | "continue"
    | "for" | "import" | "return" | "var">
        { debugStream.println("RESERVED_WORD token: " + matchedToken.image); }
    |
    <SPECIAL_SYMBOL:
    "+" | "&" | "+=" | "&=" | "&&" | "==" | "!=" | "(" | ")"
    | "-" | "|" | "-=" | "|=" | "||" | "<" | "<=" | "[" | "]"
    | "*" | "^" | "*=" | "^=" | "<-" | ">" | ">=" | "{"  | "}"
    | "/" | "<<" | "/=" | "<<=" | "++" | "=" | ":=" | "," | ";"
    | "%" | ">>" | "%=" | ">>=" | "--" | "!" | "..." |  "." | ":"
    | "&^" | "&^=">
        { debugStream.println("SPECIAL_SYMBOL token: " + matchedToken.image); }
    |
    <STRING: <RAW_STRING> | <INTERPRETED_STRING>>
        { debugStream.println("STRING token: " + matchedToken.image); }
    | <INTEGER_NUMBER: <DECIMAL> | <OCTAL> | <HEXADECIMAL>>
        { debugStream.println("INTEGER_NUMBER token: " + matchedToken.image); }
    | <REAL_NUMBER: <DECIMAL> "." (<DECIMAL>)? (<EXPONENT>)? | (<DECIMAL> <EXPONENT>)
            | ("." <DECIMAL> (<EXPONENT>)?)>
        { debugStream.println("REAL_NUMBER token: " + matchedToken.image); }
    | <RUNE_LITERAL: "'" (<UNICODE_VALUE> | <BYTE_VALUE>) "'">
        { debugStream.println("RUNE_LITERAL token: " + matchedToken.image); }
    | <IMAGINARY_NUMBER: ((<DIGIT>)+ | <REAL_NUMBER>) "i">
        { debugStream.println("IMAGINARY_NUMBER token: " + matchedToken.image); }
    | <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT> | "_")*>
        { debugStream.println("IDENTIFIER token: " + matchedToken.image); }
    | <#OCTAL: "0" (["0"-"7"])*>
    | <#HEXADECIMAL: ("0x"|"0X") (["A"-"F", "a"-"f", "0"-"9"])+>
    | <#EXPONENT: ("E"|"e") ("+"|"-")? <DECIMAL>>
    | <#LETTER: ["a"-"z", "A"-"Z"]>
    | <#DIGIT: ["0"-"9"]>
    | <#DECIMAL: <DIGIT> (<DIGIT>)*>
    | <#ADD_OP: ["+", "-", "|", "^"]>
    | <#MUL_OP: ("*" | "/" | "%" | "<<" | ">>" | "&" | "&^")>
    | <#REL_OP: ("==" | "!=" | "<" | "<=" | ">" | ">=") >
    | <#UNARY_OP: ("+" | "-" | "!" | "^" | "*" | "&")>
    | <#BINARY_OP: "||" | "&&" | <REL_OP> | <ADD_OP> | <MUL_OP>>
    | <#LITERAL_SYMBOLS: ("~" | "!" | "@" | "#" | "$" | "%" | "^" | "&" | "*"
        | "(" | ")" | "_" | "-" | "+" | "=" | "<" | ">" | "," | "." | "/"
        | "?" | ":" | ";" | "\"" | "[" | "]" | "{" | "}" | "|" | "\\") "'" >
    | <#RAW_STRING: "`" (<LETTER> | <DIGIT> | <LITERAL_SYMBOLS> | <NEWLINE>)* "`">
    | <#INTERPRETED_STRING: "\"" (<UNICODE_VALUE> | <BYTE_VALUE> | "\u672c")* "\"">
    | <#UNICODE_CHAR: "\\" (["t", "b", "f", "\\", "\"", "'"])
        | (["u", "U"] "+" <UNICODE_CODE_PT>)>
    | <#UNICODE_CODE_PT:
        ["0"-"9", "A"-"F", "a"-"f"]
        ["0"-"9", "A"-"F", "a"-"f"]
        ["0"-"9", "A"-"F", "a"-"f"]
        ["0"-"9", "A"-"F", "a"-"f"]>
    | <#UNICODE_VALUE: (<UNICODE_CHAR> | <LITTLE_U_VALUE> | <BIG_U_VALUE> | <ESCAPED_CHAR>)>
    | <#LITTLE_U_VALUE: "\\" "u" <HEXADECIMAL> <HEXADECIMAL> <HEXADECIMAL> <HEXADECIMAL>>
    | <#BIG_U_VALUE: "\\" "U" <HEXADECIMAL> <HEXADECIMAL> <HEXADECIMAL> <HEXADECIMAL>
                              <HEXADECIMAL> <HEXADECIMAL> <HEXADECIMAL> <HEXADECIMAL>>
    | <#BYTE_VALUE: <OCTAL_BYTE> <HEX_BYTE>>
    | <#OCTAL_BYTE: "\\" <OCTAL> <OCTAL> <OCTAL>>
    | <#HEX_BYTE: "\\" "x" <HEXADECIMAL> <HEXADECIMAL>>
    | <#NEWLINE: ["\r", "\n"]>
    | <#ESCAPED_CHAR: "\\" ("a" | "b" | "f" | "n" | "r" | "t" | "v" | "\\" | "'" | "\"")>
    | <#INCDEC_STATEMENT: <EXPRESSION> ("++" | "--")>
    | <#EXPRESSION_LIST: <EXPRESSION> ("," <EXPRESSION>)*>
    | <#IDENTIFIER_LIST: <IDENTIFIER> ("," <IDENTIFIER>)*>
    | <#FOR_STATEMENT: "for" (<EXPRESSION> | <FOR_CLAUSE> | <RANGE_CLAUSE>) >
    | <#FOR_CLAUSE: <SIMPLE_STATEMENT> ";" <EXPRESSION> ";" <SIMPLE_STATEMENT> >
    | <#RANGE_CLAUSE: ( <EXPRESSION_LIST> "=" | <IDENTIFIER_LIST> ":=" ) "range" <EXPRESSION>>
}
